Vorwort:

Diese Einfuehrung richtet sich an Anfaenger in lpc. Programmierkenntnisse
in anderen Sprachen sind vorteilhaft aber nicht notwendig.
Allerdings wird davon ausgegangen, das prinzipielle Computerkenntnisse -
z.b. was ist eine Datei, was ist ein Verzeichnis - und Kenntnis der
wichtigsten Magierbefehle im Tamedhon - wie erstelle ich eine Datei
in meinem Stammverzeichnis, wie lade ich Objekte im mud, ... - vorhanden
sind.

Es werden lediglich Grundzuege der Sprache beschrieben, dies soll keine
vollstaendige Dokumentation ueber lpc sein. Insbesondere werden auch
keine Standardfunktionen beschrieben, wie sie in der mudlib festgesetzt
sind. Im uebrigen bezieht sich diese Beschreibung lediglich auf lpc wie
es im mud "Tamedhon" definiert ist, und nicht auf lpc im allgemeinen.

Eigentlich sollte eine Einfuehrung in lpc ja von jemandem mit fundierten
lpc-Kenntnissen geschrieben werden. Jemand der grad mal 4 oder 5 lpc
Programme geschrieben hat, sollte da kaum geeignet sein. Aber da ich nun
mal darum gebeten wurde - von Leuten die immer noch glauben das zwischen
C und lpc nicht viel Unterschied ist ;-) - versuch ich halt mein Glueck.

Sollte jemand Fehler entdecken, vor allem Dinge die zwar unter C gelten
aber nicht unter lpc, oder umgekehrt, bitte ich diese mir mitzuteilen.
Vielleicht findet sich wegen der vielen Halbwahrheiten auch ein lpc-Experte
berufen, was besseres zu schreiben - *hint, hint*.

   Omrani@Silberland


1. Erste Schritte, ein "Hallo Welt!" Programm

Eine neue Programmiersprache lernt man am besten, wenn man in ihr Programme
schreibt. Am besten liest man sich auch vorher einige Beispielprogramme
durch, bevor man sich an sein erstes Programm wagt. Moeglichkeiten dazu
gibt es im Tamedhon ja genug. Was man am Anfang nicht ganz versteht kann
man einfach ueberlesen, bis man sich etwas besser auskennt. Die erste
Aufgabe ist meistens ein Programm zu schreiben, das die Worte "Hallo Welt!"
ausgibt.

Hier beginnen allerdings bereits unsere ersten Probleme. Lpc Programme
erfuellen die Bedingungen die ueblicherweise von Programmen erwartet
werden nur zum Teil. Es gibt in lpc Programmen zum Beispiel keinen
definierten Start, und kein definiertes Ende. Daher werden lpc Programme
auch oft als lpc Objekte bezeichnet. Anfaenger sollten aber immer
bedenken, dass der Begriff "Objekt", der schon in der Umgangssprache auf
recht viele verschiedene Arten interpretiert werden kann, auch in lpc
verschiedene Bedeutungen hat, und erst aus dem Zusammenhang hervorgeht
was nun genau gemeint ist.

Ein lp-mud besteht, grob gesagt, aus vielen kleinen lpc Objekten/Programmen
die untereinander kommunizieren, der sogenannten "mudlib". Die Kommunikation
wird dabei von einem eigenem Programm, dem driver, uebernommen. Der driver
kann auch als eine Art Betriebssystem betrachtet werden, und ist
ueblicherweise in C geschrieben.  Ein lpc Objekt/Programm wird dabei,
etwas vereinfacht ausgedrueckt, von einer Datei mit dem Programmcode
repraesentiert. Eine solche Datei hat die Endung ".c". Leider wurde hier
diesselbe Endung wie fuer C Programme verwendet, und keine eindeutig
erkennbare, wie etwa ".lpc". Das mag zum Mythos beitragen der manchmal
verwendet wird, das lpc Programme C Programme seien. Tatsaechlich
gibt es zwischen C und lpc viele Verwandtschaften, diese teilt C aber
auch mit anderen Sprache wie C++ oder Java. Ich wuerde sogar sagen das
lpc mit Java mehr gemeinsam hat, als mit C. Fuer uns reicht es aber
aus zu wissen, das lpc eine von C voellig unabhaengige Sprache ist, und
lediglich grosse Teile der Syntax von C "geklaut" hat. Lpc ist aber im
Gegensatz zu C eine objektorientierte Sprache.

Um auf unser "Hallo Welt!" Programm zurueckzukommen, muessen wir also
eine Datei, nennen wir sie "hallo.c", in unserem Stammverzeichnis erstellen.
Da ein lpc Programm, wie wir schon erfahren haben, keinen definierten
Anfang hat, muessen wir unsere Ausgabe in eine Funktion verpacken. Wir
geben unserer Funktion den - willkuerlichen - Namen "hallo".

In lpc sieht unser "Hallo Welt!" Programm/Objekt/Datei also folgendermassen
aus:

hallo()
{
  write("Hallo Welt!\n");
}

Ausfuehren koennen wir unser Programm mit dem Magierbefehl:
     xcall ~/hallo->hallo()
(Dabei wird an den Dateinamen ~/hallo automatisch die Endung .c angehaengt,
und in diesem Programm/Objekt/Datei die Funktion hallo aufgerufen.)

Auch wenn es nur 4 Zeilen sind, muessen jetzt natuerlich ein paar Erklaerungen
folgen.
Jedes lpc Objekt besteht aus Funktionen und Variablen.
Eine Funktion besteht dabei aus Anweisungen, die definieren, welche Aktionen
ausgefuehrt werden sollen, und die Variablen enthalten die Werte, die
waehrend der Ausfuehrung benutzt werden. Eine Funktion kann auch Argumente
zur Auswertung mitgeliefert bekommen und kann auch wieder einen Wert als
Ergebnis zurueckliefern. Im Gegensatz zu anderen Sprachen wie Pascal oder
Fortran, muss eine Funktion aber kein Ergebnis liefern, da lpc nicht
zwischen Funktionen und Prozeduren bzw. Unterprogrammen unterscheidet.

Die Zeile
   hallo()
in unserem ersten Programm definiert dabei einfach eine Funktion mit dem
Namen hallo, die keine Argumente erwartet. Mehr ueber Argumente und
Rueckgabewerte dann im Kapitel Funktionen.

Die geschwungenen Klammern  { }  markieren Anfang und Ende einer Funktion.
Allgemein, kann immer wenn eine Anweisung benoetigt wird, auch ein
Block von mehreren Anweisungen stehen, der von geschwungenen Klammern
umgeben ist. Das ist vergleichbar etwa mit begin und end in Pascal.
Innerhalb eines Blockes werden die Anweisungen immer eine nach der anderen
sequentiell abgearbeitet. Anweisungen werden dabei immer mit einem
Strichpunkt beendet. Man kann auch sagen, der Strichpunkt macht aus einem
Ausdruck eine Anweisung. Insbesondere ist zum Beispiel auch ein einzelner
Strichpunkt eine Anweisung, und zwar eine leere Anweisung, in der einfach
nichts geschieht.

beispiel()
{
    {
        {
            ;
        }
    }
}

Obiges Beispiel ist durchaus eine legale lpc Funktion, wenn auch keine
sehr sinnvolle, da sie einfach nichts tut.

Im Unterschied zu Sprachen wie Fortran oder Basic, ist lpc nicht zeilen-
orientiert. Das Zeilenende ist ein ganz normales Trennzeichen wie auch
das Leerzeichen oder ein Tabulator - mit Ausnahme des Praeprozessors,
von Stringkonstanten, aber dazu spaeter. Es ist vollkommen egal wieviele
und welche Trennzeichen zwischen zwei Werten stehen, sehr oft braucht man
auch gar kein Trennzeichen, wenn der Ausdruck ohnehin eindeutig ist.

a=b+1;  und  a = b + 1;  und a		=         b+1
;
sind also in lpc 3 gleiche Ausdruecke.
Wir koennten also unser "Hallo Welt!" Programm auch kuerzer schreiben:

hallo(){write("Hallo Welt!\n");}

Allerdings wird der Programmcode dadurch nicht gerade lesbarer.
Wie man Trennzeichen aber wirklich einsetzt, ist Stilfrage. Allgemein
eingebuergert hat sich, dass man Bloecke durch Einrueckung kennzeichnet,
damit kann man sehr gut erkennen, zu welchem Block eine Anweisung gehoert -
wie wir schon gesehen haben, kann man Bloecke beliebig verschachteln.

Nehmen wir ein kurzes, sinnloses ;-), Beispiel - keine Angst wenn hier noch
nicht alles verstanden wird, es geht hier nur um die Einrueckung:

int beispiel(int i)
{
    int j;

    j = 1;
    if (i == j)
    {
        write("Wert ist 1.\n");
        return 1;
    }
    else
    {
        write("Wert ist nicht 1.\n");
        return 0;
    }
}
    
Das ist durchaus ueblicher, und lesbarer Stil. Allerdings gibt es auch viele
andere Arten so etwas zu schreiben.
z.B.

int beispiel(int i)
{
  int j;

  j = 1;
  if (i == j)
    {
      write("Wert ist 1.\n");
      return 1;
    }
  else
    {
      write("Wert ist nicht 1.\n");
      return 0;
    }
}

oder

int beispiel(int i)
{
  int j;

  j=1;
  if(i==j)
    {
    write("Wert ist 1.\n");
    return 1;
    }
  else
    {
    write("Wert ist nicht 1.\n");
    return 0;
    }
}

oder

int beispiel(int i)
{
	int j;

	j=1;
	if(i==j) {
		write("Wert ist 1.\n");
		return 1;
	} else {
		write("Wert ist nicht 1.\n");
		return 0;
	}
}

...

Welchen Stil jemand bevorzugt, sollte er selbst entscheiden, aber zurecht-
finden sollte man sich auch mit anderen Stilen. Ausserdem gibt es natuerlich
auch noch ganz andere Stilfragen, die Einrueckung sei hier nur als kleines
Beispiel gezeigt.

Schlechter Stil waere aber zum Beispiel:

int beispiel(int i)
{
int j;
j=1;
if(i==j)
{
write("Wert ist 1.\n");
return 1;
}
else
{
write("Wert ist nicht 1.\n");
return 0;
}
}

Die im Tamedhon am weitesten verbreitete Methode ( und meiner Meinung nach 
auch die uebersichtlichste  (Feyaria@Silberland) ) ist folgende:

int beispiel(int i)
{
  int j;

  j = 1;
  if (i == j)
  {
    write("Wert ist 1.\n");
    return 1;
  }
  else
  {
    write("Wert ist nicht 1.\n");
    return 0;
  }
}
  

Nunja, da hab ich mal wieder den roten Faden verloren. Kommen wir also
zurueck zu unserem "Hallo Welt!" Programm. Es bleibt noch die Zeile
    write("Hallo Welt!\n");
zu erklaeren. Nun, write ist ganz einfach der Name einer Standardfunktion,
die einen Text an den Spieler, genauer an das aufrufende Objekt, ausgibt. 
Was genau eine Standardfunktion ist, dazu spaeter mehr.

"Hallo Welt!\n" ist eine konstante Zeichenkette, auch "string" genannt.
Wir sagten schon das Zeilenumbrueche in Stringkonstanten gesondert behandelt
werden. Um in der Ausgabe einen Zeilenumbruch zu bekommen, muss man
das Zeichen '\n', fuer Zeilenende, angeben. \n ist dabei nur als 1 Zeichen
zu betrachten. Mehr darueber aber im Kapitel ueber konstante Ausdruecke.


2. Kommentare

Jedes gute Programm sollte auch ein paar Kommentare enthalten, die vom
Programm einfach ignoriert werden, es aber dem menschlichen Leser leichter
machen, zu verstehen was das Programm macht.
Man mag es uebertrieben finden dafuer ein eigenes Kapitel zu opfern, aber das
erste Kapitel war einfach schon so lang.  ;-)

In lpc gibt es 2 Arten von Kommentaren.

Ein Kommentar wird durch die Zeichen /* eingeleitet und durch die Zeichen
*/ beendet. Solche Kommentare koennen nicht verschachtelt werden, seinen
Kommentar muss ja hoffentlich niemand kommentieren  :-).

Alternativ dazu kann ein Kommentar auch durch die Zeichen // eingeleitet
werden. So ein Kommentar wird dann durch das naechste Zeilenende beendet,
einer der wenigen Faelle, in denen das Zeilenende gesondert behandelt wird.

Innerhalb von Stringkonstanten koennen keine Kommentare geschrieben werden.
Der String "/* Das ist kein Kommentar */" ist also kein Leerstring.

Im allgemeinen verwendet man die /* */ Kommentare fuer ausfuehrliche
Beschreibungen, etwa ueber die Wirkung und Parameter einer Funktion, und
// Kommentare fuer kurze Zusatzerklaerungen einzelner Zeilen.


/*
    hallo ist eine kleine Beispielfunktion um den Text "Hallo Welt!"
    auszugeben, geschrieben fuer eine kleine Einfuehrung in lpc.

    Omrani@Silberland     31.10.1996
*/

hallo()
{
  write("Hallo Welt!\n");  //   hier faellt mir nichts sinnvolles ein
}

Man kann davon ausgehen, dass man kaum zu viel kommentieren kann, abgesehen
vielleicht von Uebungsbeispielen in denen man gezwungen wird einen bestimmten
Prozentsatz des Codes fuer Kommentare zu verwenden ;-). In der Praxis
kann man aber durchaus davon ausgehen, das zuwenig kommentiert wird.

Wie man nun am besten kommentiert ist, wie vieles andere auch, Stilfrage.
Man koennte auch die Einstellung haben: Es war schwierig genug das Programm
zu schreiben, also sollte es auch nicht zu einfach gemacht werden das
Programm zu lesen.
Allerdings ist das nicht gerade empfehlenswert. Man sollte immer bedenken,
das man auch nach einem Jahr noch verstehen sollte was man bezweckt hat.
Manchen gelingt dies nicht einmal nach einer Woche, mangels Konzept und
Kommentaren.

Gluecklicherweise ist lpc eine recht gut "lesbare" Sprache, so das die
Programmanweisungen selbst schon der beste Kommentar sind. Man sollte
deshalb vermeiden offensichtliche Dinge zu kommentieren, nur um sagen zu
koennen man haette ohnehin ausreichend kommentiert.
z.B. waeren die Zeilen
int tmp;  // Eine temporaere Integervariable
tmp++;  // erhoehen wir die Variable tmp um 1
absolut sinnlos kommentiert. Damit koennte man hoechstens erreichen das
man die Kommentare wegen Belanglosigkeit ignoriert, und auch sinnvolle
Kommentare nicht beachtet werden, das Programm also schlechter lesbar wird.
Das gilt natuerlich nicht wenn man einen speziellen Zweck damit befolgt,
etwa einem Anfaenger den ++ Operator zu erklaeren.

Eine gute Idee ist es aber, jeder Funktion einen Kommentar voranzustellen,
was die Funktion bewirkt und welche Parameter sie hat, sowie jeder globalen
Variablen einen Kommentar ueber Art und Verwendung der in ihm gespeicherten
Daten beizustellen. Innerhalb einer Funktion wird man Kommentare aber eher
sparsam verwenden, sollten tatsaechlich ausfuehrlichere Kommentare
notwendig sein, kann man sich durchaus fragen, ob dieser Teil nicht eine
eigene Funktion verdienen wuerde.

Manchmal werden Kommentare auch dazu verwendet bestimmte Teile eines
Programmes vorruebergehend auszuklammern, z.B. weil sie noch fehlerhaft
sind, oder veraltet, oder erst auf kommende Programmaenderungen gewartet
wird. Fuer kleinere Programmteile kann man dabei durchaus die normalen
Kommentare verwenden, sollte es sich aber um ganze Funktionen handeln,
ist die Verwendung des dafuer vorgesehenen Precompilers sinnvoller.
Schon allein weil Kommentare nicht verschachtelt werden koennen, und daher
eventuell vorhandene Kommentare fuer Fehler sorgen wuerden.

Mehr zum Preprozessor spaeter, hier nur kurz ein Beispiel wie man ihn
zum ausklammern von Code verwenden kann:

#ifdef  FERTIG    /* leider noch ein bug, da kuemmer ich mich spaeter drum */
/*
    Die Funktion soll halt irgendwas tun
*/
int irgendwas()
{
   // hier muss man sich ein paar Anweisungen denken
}
#endif


3. Variable und einfache Datentypen

Variablen und Konstanten sind die grundsaetzlichen Datenobjekte die von den
Funktionen manipuliert werden. In Ausdruecken werden Variablen und Konstanten
mit Operatoren verknuepft, um neue Werte zu produzieren.
Eine Konstante ist ein fixer Wert, der nicht mehr veraendert werden kann,
z.B. eine Zahl 1234, oder ein Text "abc".
Eine Variable ist einfach ein Speicherbereich im Hauptspeicher des Computers,
der zur Speicherung von Daten fuer unser Programm reserviert wurde. Eine
Variable muss dabei einen Namen und einen Typ haben.

Namen bestehen in lpc aus Buchstaben und Ziffern, wobei das erste Zeichen
ein Buchstabe sein muss. Zusaetzlich zaehlt auch der Unterstrich _ als
Buchstabe, er wird hauptsaechlich verwendet umd die Lesbarkeit von laengeren
Variablennamen zu erhoehen. Das erste Zeichen sollte aber kein Unterstrich
sein, da Systemfunktionen gerne diesen Namen verwenden.
Zwischen Gross- und Kleinbuchstaben wird dabei unterschieden. Ueblicherweise
werden fuer Variablennamen Kleinbuchstaben verwendet. Namen aus lauter
Grossbuchstaben sollten vermieden werden. Auch reservierte Woerter wie
if, else, for, while, void, int, float, ... sind als Variablennamen verboten.

Vernuenftigerweise waehlt man Variablennamen so, dass der Zweck einer
Variablen angedeutet wird, und eine Verwechslung durch Tippfehler
unwahrscheinlich wird. Man benutzt gerne kurze Namen fuer lokale Variablen,
insbesondere Schleifenindizes, und laengere Namen fuer globale Variablen.

gueltige Namen:
i, j, tmp, startzeit, h4711, my_obj, max_health, OriginalfarbeSpieler1

gueltig aber nicht empfehlenswert:
IllIlllII, _xyz, eine_nur_einmal_kurz_verwendete_Schleifenvariable, TMP, I

verbotene Namen:
1haus, tmp-npc, if, int, mein kasten, geld$

Neben dem Namen muss in einem Programm auch der Typ einer Variablen bekannt
sein, um zu wissen welche Art von Daten darin gespeichert werden koennen.
Lpc kennt die Datentypen void, int, status, string, object, array, mapping,
closure und mixed. Anders als in C gibt es in lpc keine strenge
Typueberpruefung. Lpc verhaelt sich hier aehnlich wie neuere Basic Dialekte.
Trotzdem sollte man auf Typenreinheit achten, will man verstaendliche und
robuste Funktionen schreiben. Zum Glueck gibt es aber keine implizite
Datenvereinbarung wie in Basic oder mit Standardeinstellungen auch in Fortran.

Variablen muessen in lpc vereinbart werden, bevor sie verwendet werden
koennen. Eine solche Vereinbarung besteht einfach aus dem Datentyp gefolgt
vom Variablennamen.
z.b.  int i; string ausgabe; status gestorben;
Es koennen auch mehrere Variablen mit dem selben Typ in einer einzigen
Vereinbarung deklariert werden indem die Namen durch einen Beistrich
getrennt werden.
z.b.  mixed a, b, c; 

Erfolgt die Vereinbarung einer Variablen ausserhalb einer Funktion, so
ist die Variable eine globale Variable. Jede Funktion unseres Programmes
kann die Variable manipulieren. Von fremden Programmen/Objekten kann
aber in lpc niemals auf Variablen direkt zugegriffen werden.
Die Variable existiert dann solange, wie das Objekt existiert.

Wird ein Wert aber nur voruebergehend benoetigt, ist eine lokale Vereinbarung
vorzuziehen. Die Vereinbarungen muessen als erste Befehle innerhalb eines
Blockes stehen. Auf die Werte kann aber dann nur innerhalb dieser einen
Funktion, bzw. eines Blockes, zugegriffen werden. Ausserdem wird der
Anfangswert bei jedem Funktionsaufruf neu gesetzt.

int gewinn;       // das ist eine globale Variable
/* irgendeine Funktion */
test()
{
  int nummer;     // eine lokale Variable

  /* Hier kommen ein paar Anweisungen */

  {
     int i;  // eine andere lokale Variable, nur innerhalb des Blocks gueltig

     i = 1 + 2;
  }
  write(i);   //  FEHLER !  i ist nicht mehr definiert
}

Jede Variable ist anfangs mit dem Wert Null initialisiert. Guter Stil ist es
aber diese Tatsache nicht wirklich zu verwenden, und jede Variable, bei der
dies notwendig ist, explizit zu initialisieren.
int i; i = 0; write(i);

Der Typ void:

Void ist eigentlich das Fehlen eines Datentyps. Void kann keinerlei Daten
speichern, und ist so etwas wie ein leerer Datentyp. Es macht natuerlich
keinen Sinn eine Variable zu vereinbaren, in der keinerlei Daten gespeichert
werden koennen, daher ist das auch nicht erlaubt. Einen Sinn erhaelt void
nur als Rueckgabewert von Funktionen oder Ausdruecken. Z.B. wenn festgelegt
wird, dass eine Funktion keinen Wert als Ergebnis zurueckliefert.
Wird der Typ void in den Typ int umgewandelt, so ist das Ergebnis 0.

Der Typ int:

Int ist der haeufigste Datentyp in lpc. Er dient zum Speichern ganzer
Zahlen. Lpc reserviert 32 Bit fuer einen Integer, das ergibt einen
Wertebereich von -2147483648 bis 2147483647.
Integerkonstanten bestehen ganz einfach aus Ziffern und einem optionalen
Vorzeichen. Normal werden Integerkonstanten dezimal angegeben, beginnt
die Konstante mit 0x so ist es eine Hexadezimalkonstante, dann koennen
auch die Buchstaben A bis F, bzw. a bis f verwendet werden. 0xf37c
entspricht z.B. 62332. Oktalkonstanten wie in C gibt es in lpc keine.
Da es in lpc keinen char Typ gibt, wird fuer einzelne Textzeichen auch
der Typ int verwendet. Dabei entspricht der Zahlenwert dem ASCII-Wert
eines Zeichens. Konstanten werden von einem ' umschlossen.
'A' entspricht also dem Wert 65, ' ' dem Wert 32, 'z' dem Wert 122, usw.
Daher entspricht eine Zuweisung der Art i = '1' natuerlich auch dem
Wert i = 49 und nicht i = 1.

Der Typ status:

Status ist der boolsche Typ in lpc. Er kann genau zwei Werte haben,
0 oder 1.  0 entspricht dem Wert falsch, oder FALSE, und 1 dem Wert
wahr oder TRUE.
Es gibt keine eigentlichen status Konstanten, man benutzt einfach
Integerkonstanten, die bei Bedarf implizit in den Typ status gewandelt
werden.  Ein Integerwert von 0 wird dabei zu 0 (falsch), jeder andere
Integerwert wird zu 1 (wahr).  Generell ist in boolschen Ausdruecken in
lpc immer alles was null ist als falsch zu betrachten, und alles was
ungleich null ist, als wahr.
Haeufig verwendet man auch die Preprozessorasudruecke #define FALSE 0
und #define TRUE 1, um Zuweisungen der Art   status fertig = FALSE;
zu erlauben.

Der Typ float:

Float wird zur Speicherung von Realzahlen verwendet. Lpc verwendet dafuer
doppelte Genauigkeit, das entspricht einem Platzverbrauch von 64 Bit.
Dies ergibt in etwa eine Genaugkeit von 15 Dezimalstellen fuer die Mantisse
und einen Exponenten im Bereich von -324 bis 308.
Man sollte aber bedenken, das Realzahlen wegen der beschraenkten Genauigkeit
der Darstellung immer zu Rechenungenauigkeiten fuehren koennen, die sich
bei schlechten Algorithmen bemerkbar machen. Auch entspricht z.B. 1.0
nicht exakt dem Integerwert 1, was vor allem bei Vergleichen zwischen
Realzahlen immer beachtet werden sollte.
Konstante float Zahlen werden einfach durch auftreten des Dezimalpunktes
in einer Zahl angegeben.
1. oder 1.0 oder 0.99 oder 10004.11 sind gueltige float Konstante.
Die Exponentialschreibweise, wie sie in lpc auch in der Ausgabe verwendet
wird, kann fuer konstante Werte aber leider nicht verwendet werden.
z.b. 1.37e+10  oder  7.14e-112

Der Typ string:

Anders als in C, das keine Strings kennt und nur mit Charakter Arrays
arbeitet, gibt es in lpc einen echten string Typ. Er wird benutzt um
Texte zu speichern. Die Laenge eines strings ist variabel. Der Platzbedarf
eines strings passt sich dynamisch der benoetigten Textlaenge an.
Textkonstanten werden in lpc von doppeltem Hochkomma umgeben. Gueltige
Werte sind dabei alle ASCII Zeichen von 32 (Leerzeichen) bis zu 126 (Tilde).
Der umgekehrte Schraegstrich \ hat eine besondere Bedeutung, um auch die
Verwendung bestimmter Steuerzeichen zu ermoeglichen.
\n  ... Zeilenende, newline, linefeed
\t  ... Tabulator
\v  ... vertikaler Tabulator
\b  ... Zeichen zurueck, backspace
\f  ... Seitenvorschub
\a  ... Klingelzeichen, bell
\\  ... umgekehrter Schraegstrich, backslash
\"  ... doppeltes Anfuehrungszeichen, 
\'  ... Hochkomma
\r  ... Return, ist zwar erlaubt, wird aber in der Ausgabe ignoriert
\e  ... Escape Zeichen, fuer Escape Sequenzen
        (Fettdruck, unterstrichen, Farben, ... auf manchen Terminals)
Zeichen des internationalen Standardzeichensatzes (ISO-8859-1) ueber 127,
also solche die das 8.Bit verwenden - und damit nicht dem amerikanischen
Standard ASCII entsprechen - koennen in lpc leider nicht verwendet werden.
Insbesondere betrifft dies alle Umlaute und das scharfe s, was besonders
im deutschsprachigen Tamedhon bedauerlich ist.
Anmerkung: Fuer den Zeilenumbruch verwendet lpc, wie auch unix, nur das
einzelne Zeichen \n. Die Umwandlung in einen Wagenruecklauf plus Zeilen-
vorschub, wie vom telnet Protokoll gefordert (CR/LF, \r\n), erfolgt erst
durch den driver des muds.
"Omrani sagt: \"Ok.\"\n"      ... Eine Textkonstante der Laenge 19

Der Typ mixed:

Dieser Typ steht fuer jeden beliebigen Typ in lpc. Eine Variable des
Typs mixed kann Werte jeden Typs aufnehmen. Welchen Typ die Variable
im Moment hat, kann mit Standardfunktionen abgefragt werden.
Natuerlich kann es keine eigenen Konstanten des Typs mixed geben.
Mixed Variablen sollte man in lesbaren Programmen aber nur verwenden,
wenn die Variable tatsaechlich verschiedene Typen annehmen kann, und
nicht aus reiner Gewohnheit, um nicht ueberlegen zu muessen, was fuer
einen Typ die gespeicherten Werte haben koennen.

Die Typen object, array, mapping und closure sind kompliziertere Datentypen,
und werden vielleicht einmal in einem eigenen Kapitel behandelt.

4. Operatoren:

Um die verschiedenen Werte zu verknuepfen und bearbeiten, benoetigt man
Operatoren. Alle Operatoren haben 1 oder mehr Argumente und liefern einen
Wert als Ergebnis zurueck. Die meisten Operatoren koennen nur auf bestimmte
Datentypen angewendet werden, manche Operatoren haben auch mehrfache
Bedeutung, je nach dem Typ der Argumente. Stimmt der Typ der Argumente
nicht ueberein, so wird, wenn moeglich, das Argument mit dem niederen Typ
automatisch in einen Wert mit dem hoeheren Typ umgewandelt. Das Ergebnis
hat dann den hoeheren Typ. Als Wertigkeit gilt dabei die Reihenfolge
  status -> int -> float -> string 

17 * 1.1 liefert z.B. als Ergebnis die Realzahl 18.7 oder "Wert: " + 12
den Text "Wert: 12".

Nach der Anzahl der Argumente unterscheidet man auch unaere (1 Argument),
binaere (2 Argumente) und ternaere (3 Argumente) Operatoren.

=  Der Zuweisungsoperator:    <Variable> = <Ausdruck>

In der Variablen auf der linken Seite, wird der Wert des Ausdrucks
auf der rechten Seite gespeichert. Als Ergebnis wird der neue Inhalt
zurueckgegeben. Das unterscheidet die Zuweisung in lpc, von anderen
Sprachen wie Pascal, in denen die Zuweisung selbst keinen Rueckgabewert
liefert. Der Zuweisungsoperator ist auf fast alle Datentypen anwendbar,
wobei versucht wird den Typ des Arguments, dem Typ der Variablen anzupassen.
Ist dies nicht moeglich, wird ein Fehler gemeldet.

Beispiele:
i = 7;
str = "abc";
spieler = this_player();
x = y = z;  // Da die Zuweisung von rechts erfolgt, wird zuerst der Inhalt
            // von z der Variablen y zugewiesen, das Ergebnis (wieder der
            // Inhalt von z) wird anschliessend der Variablen x zugewiesen.
i = "7";  // wuerde einen Fehler liefern, wenn i eine int Variable ist.
7 = 0;    // FEHLER! weil auf der linken Seite eine Variable und kein
          // Ausdruck stehen muss.

-  Der Negativoperator:    - <Ausdruck>

Kann nur auf Zahlen (int, float) angewandt werden. Gibt den negativen
Wert des Ausdrucks zurueck.

Beispiele:
- 543    //  -543
- i      //  entspricht 0 - i

+  Der Additionsoperator:    <Ausdruck1> + <Ausdruck2>

Angewandt auf Zahlen (int, float) wird eine arithmetische Addition
durchgefuehrt, angewandt auf strings, arrays oder mappings 
werden die einzelnen Werte aneinandergehaengt.

Beispiele:
1 + 1          //   2
3 + 14.7       //  17.7
"17" + "4"     //  "174"
"Wert: " + x   // wenn x==2 ->   "Wert: 2"
({ 1, "xx" }) + ({ 2 })  // ({ 1, "xx", 2 }), aber mehr zu arrays spaeter

-  Der Subtraktionsoperator:    <Ausdruck1> - <Ausdruck2>

Angewandt auf Zahlen (int, float) wird eine arithmetische Subtraktion
durchgefuehrt. Auf strings kann der Subtraktionsparameter nicht angewandt
werden. In arrays und mappings werden die Elemente von Ausdruck2 aus
Ausdruck1 entfernt. (Sollte Ausdruck1 eine Variable sein, bleibt ihr Inhalt
natuerlich in jedem Fall unveraendert.)

Beispiele:
10 - 23          // -13
18.8 - 15.8      // 3.0
"abcde" - "de"   // FEHLER
({ 1, "xx", 2 }) - ({ 1 })   //  ({ "xx", 2 }), aber mehr zu arrays spaeter

*  Der Multiplikationsoperator:    <Ausdruck1> * <Ausdruck2>

Multiplikation ist nur fuer Zahlen (int, float) als arithmetische
Multiplikation definiert.

Beispiele:
6 * 7        // 42
6.25 * 6.72  // 42.

/  Der Divisionsoperator:    <Ausdruck1> / <Ausdruck2>

Division ist nur fuer Zahlen (int, float) als arithmetische Division
definiert. Sind beide Argumente ganze Zahlen, so wird ein eventuell
auftretender Rest ignoriert.

Beispiele:
28 / 7           // 4
1 / 3            // 0
-5 / 2           // -2
735 / 12         // 61
735. / 12.       // 61.25
0.0012 / 100000  // 1.2e-08
1 / 0            // FEHLER, Division durch 0, das Programm wird abgebrochen

%  Der Modulooperator:    <Ausdruck1> % <Ausdruck2>

Modulo ist nur fuer ganze Zahlen (int) definiert. Ergebnis ist der Rest
einer Integer Division.

Beispiele:
28 % 7     // 0
32 % 5     // 2
-73 % 10   // -3

++  Der Postinkrementoperator:    <Variable> ++

Die Variable wird inkrementiert (um 1 erhoeht). Ergebnis ist der Wert
der Variablen _vor_ der Inkrementierung. Kann nur auf int Werte angewandt
werden.

Beispiele:
i++    // i wird um 1 erhoeht, Ergebnis ist der urspruengliche Wert von i
i++;   // i wird um 1 erhoeht, das Ergebnis wird ignoriert
i = 0;  j = i++;  // i enthaelt den Wert 1, j den Wert 0

++  Der Praeinkrementoperator:    ++ <Variable>

Die Variable wird inkrementiert (um 1 erhoeht). Ergebnis ist der Wert
der Variablen _nach_ der Inkrementierung. Kann nur auf int Werte angewandt
werden.

Beispiele:
++i    // i wird um 1 erhoeht, Ergebnis ist der neue Wert von i
++i;   // i wird um 1 erhoeht, das Ergebnis wird ignoriert
i = 0;  j = ++i;  // i enthaelt den Wert 1, j den Wert 1

--  Der Postdekrementoperator:    <Variable> --

Die Variable wird dekrementiert (um 1 verringert). Ergebnis ist der Wert
der Variablen _vor_ der Dekrementierung. Kann nur auf int Werte angewandt
werden.

Beispiele:
i--    // i wird um 1 verringert, Ergebnis ist der urspruengliche Wert von i
i--;   // i wird um 1 verringert, das Ergebnis wird ignoriert
i = 0;  j = i--;  // i enthaelt den Wert -1, j den Wert 0

--  Der Praedekrementoperator:    -- <Variable>

Die Variable wird dekrementiert (um 1 verringert). Ergebnis ist der Wert
der Variablen _nach_ der Dekrementierung. Kann nur auf int Werte angewandt
werden.

Beispiele:
--i    // i wird um 1 verringert, Ergebnis ist der neue Wert von i
--i;   // i wird um 1 verringert, das Ergebnis wird ignoriert
i = 0;  j = --i;  // i enthaelt den Wert -1, j den Wert -1

==  Der Gleichheitsoperator:    <Ausdruck1> == <Ausdruck2>

Sind die beiden Ausdruecke gleich, so wird als Ergebnis 1 (TRUE) geliefert,
sind die beiden Ausdruecke nicht gleich ist das Ergebnis 0 (FALSE).
Der Gleichheitsoperator kann auf alle Datentypen angewandt werden.

Beispiele:
1 == 2            //  0
"abc" == "abc"    //  1
1./3 == 0.333333  // 0, die Werte sind nur fast gleich, fuer float Werte
                  // sollte man besser mit einer Genauigkeitsschranke
                  // vergleichen.   1./3 - 0.333333 < epsilon

!=  Der Ungleichheitsoperator:    <Ausdruck1> != <Ausdruck2>

Die Umkehrung des Gleichheitsoperators. Gleichheit liefert 0 (falsch),
Ungleichheit 1 (wahr).

Beispiele:
1 != 0             //  1
"abc " != "abc"    //  0
x != x             //  0

>  <  >=  <=  Die Vergleichsoperatoren:
<Ausdruck1> > <Ausdruck2>
<Ausdruck1> < <Ausdruck2>
<Ausdruck1> >= <Ausdruck2>
<Ausdruck1> <= <Ausdruck2>

Mit den Vergleichsoperatoren kann man ueberpruefen ob ein Ausdruck groesser
oder kleiner als ein anderer ist. Trifft die Bedingung zu ist das Ergebnis
1, trifft sie nicht zu 0. Mit > wird auf groesser als getestet, mit < auf
kleiner als, mit >= auf groesser oder gleich, und mit <= auf kleiner oder
gleich.  Wie man sieht ist > das Gegenteil von <= und < das Gegenteil von
>=. Die Vergleichsoperatoren koennen auf Zahlen (int, float) oder strings
angewandt werden. Bei strings wird dabei nach dem ASCII Code sortiert.

Beispiele:
1 > 1        //  0
2 <= 2       //  1
4 > 1        //  1
-1 < 10      //  1
17.3 >= 17.4 //  0
"a" < "b"    //  1
"xz" > "y"   //  0
"a" <= "A"   //  0

!  Der Negationsoperator:    ! <Ausdruck>

Der Negationsoperator kann nur auf boolsche Werte angewandt werden.
Int Werte werden automatisch umgewandelt. Aus 0 wird dabei 1, aus 1
wird 0.

Beispiele:
!0     // 1
!1     // 0
!-1    // 0
!514   // 0

&&  Der logische Und Operator:    <Ausdruck1> && <Ausdruck2>

Angewandt auf boolsche Werte. Es wird eine "und" Beziehung berechnet.
Steht das Ergebnis nach Berechnung von Ausdruck1 bereits fest, so wird
Ausdruck2 NICHT berechnet. Das ist wichtig, wenn Ausdruck2 einen Fehler
liefern wuerde, wenn Ausdruck1 nicht erfuellt ist. Z.B. liefert
i && 12/i garantiert keinen Fehler, bei i == 0.

Beispiele:
0 && 0   // 0
0 && 1   // 0
1 && 0   // 0
1 && 1   // 1
2 && 4   // 1

||  Der logische Oder Operator:    <Ausdruck1> || <Ausdruck2>

Angewandt auf boolsche Werte. Es wird eine "oder" Beziehung berechnet.
Auch hier wird Ausdruck2 nicht mehr bewertet, wenn das Ergebnis bereits
feststeht, im Fall von || also Ausdruck1 einen Wert ungleich 0 liefert.

Beispiele:
0 || 0   // 0
0 || 1   // 1
1 || 0   // 1
1 || 1   // 1
2 || 4   // 1


Bitoperatoren:
Alle Bitoperatoren koennen nur auf den Typ int angewandt werden.
Um Bitoperatoren zu verstehen, muss man mit Binaerzahlen umgehen koennen.
Wer nicht weiss was Binaerzahlen sind, kann die Bitoperatoren ruhig
ueberspringen.
In lpc besteht ein int Wert aus 32 Bits. Der Wert 0 wird in
Binaerdarstellung 00000000000000000000000000000000 geschrieben. -1 entspricht
11111111111111111111111111111111. Alle Bitoperatoren behandeln jedes Bit
einer Int Zahl einzeln.
Alternativ zu int Zahlen, kann man in lpc auch strings zur Speicherung
einzelner Bits verwenden. Die Anzahl der Bits in strings ist nach oben
offen, im Gegensatz zur fixen Zahl in Integern. Pro Zeichen koennen in
strings 6 Bits gespeichert werden. Inkonsequenterweise koennen Bitoperatoren
aber nicht auf strings angewandt werden. Zum Zugriff auf einzelne Bits
in strings muessen daher Funktionen verwendet werden.

~  Der bitweise Negationsoperator:    ~ <Ausdruck>

Angewandt auf Integer Werte. Es wird eine "nicht" Beziehung berechnet.

Beispiele:
~0    // -1
~-1   // 0
~172  // -173

&  Der bitweise Und Operator:    <Ausdruck1> & <Ausdruck2>

Angewandt auf Integer Werte. Es wird eine "und" Beziehung berechnet.

Beispiele:
1 & 2      // 0
1 & 3      // 1
26 & 6     // 2
-12 & 12   // 4

|  Der bitweise Oder Operator:    <Ausdruck1> | <Ausdruck2>

Angewandt auf Integer Werte. Es wird eine "oder" Beziehung berechnet.

Beispiele:
1 | 2      // 3
1 | 3      // 3
26 | 6     // 30
-12 | 12   // -4

^  Der bitweise Exklusivoder Operator:    <Ausdruck1> ^ <Ausdruck2>

Angewandt auf Integer Werte. Es wird eine "exklusive oder" Beziehung berechnet.

Beispiele:
0 ^ 0           // 0
0 ^ 1           // 1
1 ^ 0           // 1
1 ^ 1           // 0
13123 ^ 8352353 // 8339746

<<  Der bitweise leftshift Operator:    <Ausdruck1> << <Ausdruck2>

Angewandt auf Integer Werte. Ausdruck1 wird um Ausdruck2 Bits nach
links verschoben. x << 1 entspricht z.B. einer Multiplikation mit 2.
Bit 32 wird dabei ignoriert, Bit 1 mit 0 gefuellt.
Fuer Werte von Ausdruck2 < 0 ist das Ergebnis nicht definiert. 

Beispiele:
128 << 4   // 2048
-1 << 1    // -2
433 << 12  // 1773568

>>  Der bitweise rightshift Operator:    <Ausdruck1> >> <Ausdruck2>

Angewandt auf Integer Werte. Ausdruck1 wird um Ausdruck2 Bits nach
rechts verschoben. x >> 1 entspricht z.B. einer Division durch 2.
Bit 1 wird dabei ignoriert, auf Bit 32 wird das Vorzeichenbit nachgeschoben,
auf anderen Rechnern koennte aber durchaus auch mit 0 gefuellt werden.
Fuer Werte von Ausdruck2 < 0 ist das Ergebnis nicht definiert. 

Beispiele:
128 >> 4   // 8
-2  >> 1   // -1
433 >> 12  // 0


+=  -=  *=  /=  %=  &=  |=  ^=  <<=  >>=  Die erweiterten Zuweisungsoperatoren:
<Variable> += <Ausdruck>
<Variable> -= <Ausdruck>
<Variable> *= <Ausdruck>
<Variable> /= <Ausdruck>
<Variable> %= <Ausdruck>
<Variable> &= <Ausdruck>
<Variable> |= <Ausdruck>
<Variable> ^= <Ausdruck>
<Variable> <<= <Ausdruck>
<Variable> >>= <Ausdruck>

Fuer die binaeren Operatoren gibt es besondere Zuweisungsoperatoren, um
haeufig gebrauchte Zuweisungen einfacher und schneller durchfuehren zu
koennen. Fuer einen Operator O entspricht die Kurzform O= der abgekuerzten
Schreibweise fuer  <Variable> = <Variable> O ( <Ausdruck> ).
Man beachte hier auch die Klammer um den Ausdruck.  x *= y + 1;  ist
aequivalent zu  x = x * (y + 1);  und nicht zu  x = x * y + 1;
Diese Schreibweise erhoeht auch die Lesbarkeit eines Programmes, da man
z.B. x += 2 als "erhoehe x um 2" lesen kann, waehrend man x = x + 2
umstaendlicher mit "addiere 2 zu x und uebergib das Ergebnis wieder an x"
lesen muesste.
Auch die erweiterten Zuweisungsoperatoren liefern als Ergebnis den Wert
der Variablen nach der Zuweisung.

Beispiele: (jeweils unter der Vorraussetzung i = 10)

i += 3    // 13
i -= 3    // 7
i *= 3    // 30
i /= 3    // 3
i %= 3    // 1
i &= 3    // 2
i |= 3    // 11
i ^= 3    // 9
i <<= 3   // 80
i >>= 3   // 1

&  Der Adressoperator:    & <Variable>

In lpc kann der Adressoperator nur im Funktionskopf verwendet werden,
um anzuzeigen das eine Variable als Referenz und nicht als Wert uebergeben
wird. Mehr dazu im Kapitel ueber Funktionen.

Beispiele:
int test(int &i)

->  Der Funktionsoperator fuer Objekte:
<Objekt> -> <Funktion> (<Argumente>)

Mit dem Funktionsoperator fuer Objekte kann man Funktionen anderer
Objekte aufrufen. Funktionen des eigenen Objektes, oder Standardfunktionen
koennen direkt aufgerufen werden. Mehr zu Funktionsaufrufen aber im
Kapitel ueber Funktionen.

Beispiele:
"~/hello"->hello() 
this_player->name()

::  Der Funktionsoperator fuer vererbte Funktionen:
<Ahnobjekt> :: <Funktion> (<Argumente>)

Mit dem Funktionsoperator fuer vererbte Funktionen kann man Originalfunktionen
aufrufen, die das Programm von anderen Programmen geerbt hat. Wird das
Ahnobjekt nicht explizit angegeben, so wird das Objekt verwendet, das zuletzt
eine Funktion dieses Namens vererbt hat. Mehr ueber Vererbung in einem
eigenen Kapitel.

Beispiele:
::create()
life::heart_beat()

[ ]  Der Indexoperator:  <Ausdruck1> [ <Ausdruck2> ]

Der Indexoperator kann auf strings, arrays und mappings angewandt zu werden.
Ausdruck2 ist ein Integer, oder im Fall von mappings ein Typ des mapping
index. Fuer strings wird als Rueckgabe das Zeichen der Zahl von Ausdruck2
geliefert. Bei arrays wird das entsprechende Element geliefert, bei mappings
wird nach einem Element gesucht das Ausdruck2 entspricht.
Dabei ist zu beachten, dass mit 0 zu zaehlen begonnen wird. Ein Index von 1
entspricht also dem 2.Element. Will man vom Ende zaehlen, so kann man dem
Index ein < voranstellen. Das letzte Element entspricht dabei <1.

Beispiele:
"abcde"[0]          // 'a'  (97)
"abcde"[4]          // 'e'  (101)
"abcde"[<2]         // 'd'  (100)
({ 1, 2, 3 }) [1]   // 2
([ "a": 1; 2, "b": 3; 4 ]) ["a"]      // 1
([ "a": 1; 2, "b": 3; 4 ]) ["b", 1]   // 4

..  Der Bereichsoperator: <Ausdruck1> [ <Ausdruck2> .. <Ausdruck3> ]

Zusaetzlich zu einzelnen Werten kann man auch ganze Bereiche aus einem
string oder array holen. Dabei sind die Grenzwerte miteingeschlossen,
bei fehlen eines Wertes, wird vom Anfang bzw. bis zum Ende gezaehlt.

Beispiele:
"abcde"[1..3]     // "bcd"
"abcde"[2..]      // "cde"
"abcde"[3..2]     // ""
({ 1, 2, 3, 4 }) [1..<3]   // ({ 2 })

({ })  Der Array Konstruktor: ({ <Ausdruck1>, <Ausdruck2>, ..., <Ausdruckn> })

Mit dem Array Konstruktor koennen aus beliebig vielen einzelnen Elementen
arrays aufgebaut werden. Mehr dazu siehe arrays.

Beispiele:
({ 1, "a", 3*4, "ab"+"c", ({ 1, 2 }) })   // ({ 1,"a",12,"abc",({ 1, 2 })})

([ ])  Der Mapping Konstruktor:
([ <Index1> : <Ausdruck1_1>; <Ausdruck2_1>; ...; <Ausdruckn_1>, 
   <Index2> : <Ausdruck1_2>; <Ausdruck2_2>; ...; <Ausdruckn_2>, 
     ...          ...            ...        ...      ...
   <Indexm> : <Ausdruck1_m>; <Ausdruck2_m>; ...; <Ausdruckn_m> ])

Mit dem Mapping Konstruktor koennen aus beliebig vielen einzelnen Elementen
mappings aufgebaut werden. Mehr dazu siehe mappings.

Beispiele:
([ "a": 1; 2, "b": 1+2; 3*3, "a"+"c": 0; 0 ])   // (["a":1;2,"ac":0;0,"b":3;9])

#'  Der Closure Konstruktor:  #' <Funktion oder Operator>

Closures dienen, vereinfacht gesagt, dazu Funktionen bzw. Operatoren einer
Variablen zuzuweisen, und diese spaeter zu verwenden. Der closure Operator
dient zur Typumwandlung. Mehr zu closures aber vielleicht einmal in einem
eigenen Kapitel.

Beispiele:
#'+            // Eine closure mit dem + Operator als Inhalt
#'this_player  // Eine closure mit der Funktion this_player()

,  Der Kommaoperator:  <Ausdruck1> , <Ausdruck2>

Zuerst wird Ausdruck1 ausgewertet, danach Ausdruck2. Rueckgabewert ist das
Ergebnis von Ausdruck2. Man braucht den Kommaoperator wenn mehrere Ausdruecke
innerhalb einer einzelnen Anweisung berechnet werden soll. Das aehnelt
einem Block  { a = 1; b = i + 2; }, kann aber zum Unterschied von Bloecken,
die fuer eine Anweisung stehen, auch als Teilausdruck verwendet werden,
und liefert auch ein Ergebnis zurueck. Wenn moeglich sollte man daher zur
besseren Lesbarkeit Bloecke verwenden, und den Kommaoperator nur wenn ein
Block nicht moeglich ist. Die haeufigste Verwendung des Kommaoperators
duerfte wohl in einer for Schleife liegen.

Beispiele:
1,2                 // 2
i = 0, j = 1        // 1
i = "a", i += "b"   // "ab"

? :  Der Konditionaloperator:  <Ausdruck1> ? <Ausdruck2> : <Ausdruck3>

Ausdruck1 muss einen logischen Wert als Ergebnis haben. Ist das Ergebnis
wahr (ungleich 0) so wird Ausdruck2 ausgewertet, ist das Ergebnis falsch
wird Ausdruck3 ausgewertet. Der Konditionalparameter entspricht einer
if - else Bedingung, liefert aber im Gegensatz dazu einen Ergebniswert
und kann auch als Ausdruck verwendet werden.

Beispiele:
1 ? 17 : 4   // 17
0 ? 17 : 4   // 4
x + " Kerze" + (x==1 ? "" : "n")  // fuer x=1  "1 Kerze", fuer x=2  "2 Kerzen"


Klammern:
In lpc werden die meisten Operatoren von links her ausgewertet, der Ausdruck
16 / 2 / 2 ergibt also 4 und nicht 16. Ausserdem binden manche Operatoren
staerker als andere. Wie in der Mathematik gilt z.B. Punkt- vor Strich-
rechnung.   12 + 3 * 2 ist also 18 und nicht 30.
Will man diese Reihenfolge veraendern, kann man Teilausdruecke in runde
Klammern einschliessen. Klammern koennen dabei beliebig verschachtelt werden.
Bei den schon erwaehnten Beispielen wuerde z.B. (12 + 3) * 2 oder 16 / (2 / 2)
das Ergebnis veraendern, waehrend in (16 / 2) / 2 oder 12 + (3 * 2) die
Klammern ueberfluessig sind.
In solch offensichtlichen Faellen sollte man ueberfluessige Klammern wegen
der Lesbarkeit eher vermeiden, ist man sich aber nicht ganz sicher, etwa bei
den logischen Operatoren && und ||, so koennen Klammern nie schaden.
Beachten sollte man noch, dass sich die Auswertung von links nur auf die
Werte bezieht, aber nicht notwendigerweise auf eventuelle Nebenwirkungen.
Der Ausdruck (i = 1) + (i = 2) muss z.B. immer 3 als Ergebnis liefern,
aber ob i nun 1 oder 2 ist, koennte durchaus vom driver abhaengen. Solche
Nebenwirkungen sollte man also vermeiden.

Vorrang der Operatoren:
( ) [ ] ([ ]) ({ }) #' :: ->
++ -- ! ~ -     
* / %
+ -
<< >>
< > <= >=
== !=
&
^
|
&&
||
?:
= += -= *= /= %= &= |= ^= <<= >>=
,

5. Kontrollstrukturen

Bedingungen:  if else
if ( <Ausdruck> ) <Anweisung> else <Anweisung>

